import 'dart:async';import 'dart:convert';import 'dart:developer';import 'dart:io';import 'package:collection/collection.dart';import 'package:connectivity_plus/connectivity_plus.dart';import 'package:dio/dio.dart';import 'package:flutter/material.dart';import 'package:flutter_bloc/flutter_bloc.dart';import 'package:equatable/equatable.dart';import 'package:intl/intl.dart';//import 'package:mytracker_sdk/mytracker_sdk.dart';import 'package:shared_preferences/shared_preferences.dart';import 'package:untitled/Screens/Chat/chat_class.dart';import 'package:untitled/Screens/Chat/local/localChatRepo.dart';import 'package:untitled/ServiceItems/network_service.dart';part 'chat_with_user_event.dart';part 'chat_with_user_state.dart';class ChatWithUserBloc extends Bloc<ChatWithUserEvent, ChatWithUserState> {  ChatWithUserBloc({required ChatWithLastMessage chatData})      : super(ChatWithUserInitial(chatData: chatData)) {    on<LoadChatData>(_loadChatData);    on<NewMessage>(_newMessage);    on<ReadMessage>(_readMessage);    on<BlockChat>(_blockChat);    on<SendTextMessage>(_sendMessage);    on<SendFile>(_sendFile);    on<AsnwerChat>(answerChat);    on<RemoveAnswerChat>(removeAnswerChat);    on<EditChat>(editChat);    on<EditChatActive>(editChatActive);    on<RetrySendAllUnsentMessages>(_resendUnsentMessages);    on<RetrySendSingleMessage>(_retrySendSingleMessage);    on<DeleteChatMessageWithId>(_deleteMessageWithId);  }  Future<void> _retrySendSingleMessage(      RetrySendSingleMessage event, Emitter<ChatWithUserState> emit) async {    final chatId = (state as ChatWithUserInitial).chatData!.chatId!.toString();    // Получаем список неотправленных сообщений для этого чата    final unsentMessages =        await LocalMessageStorage.loadUnsentMessagesForChat(chatId);    // Находим сообщение с нужным id    final ChatMessage? message = unsentMessages.firstWhereOrNull(      (msg) => msg.messageId == event.messageId,    );    print("message for retry: $message");    if (message == null) return;    List<ChatMessage> messages =        (state as ChatWithUserInitial).messages.reversed.toList();    final int index =        messages.indexWhere((m) => m.messageId == event.messageId);    if (index != -1) {      ChatMessage updatedMessage = messages[index].copyWith(        sendedError: false,        isMessageSend: false,      );      messages[index] = updatedMessage;      // Обновляем UI, чтобы сразу отобразить изменения      emit((state as ChatWithUserInitial)          .copyThis(messages: messages.reversed.toList()));    }    try {      await getAccessToken();      if (message.messageType == "file" ||          message.messageType == "image" ||          message.messageType == "video" ||          message.messageType == "audio") {        var response = await NetworkService().UploadFileRequest(          accessToken!,          message.message!,          message.messageType!,        );        // Check response status code        if (response.statusCode != 200) {          throw Exception('Failed to upload file: ${response.statusCode}');        }        // Collect the entire response body as a string        final responseBody = await response.stream.bytesToString();        // Debug print for response body        print('Response body: $responseBody');        // Decode the response body        final valueMap = json.decode(responseBody);        // Extract the file URL        final url = valueMap["fileURL"];        // Send message with the file URL        await NetworkService().ChatsSendMessage(          accessToken!,          url.toString(),          (state as ChatWithUserInitial).chatData!.chatId!,          message.messageType!,        );        if (response.statusCode == 200) {          // Если успешно, удаляем сообщение из локального хранилища          await LocalMessageStorage.removeUnsentMessage(              chatId, message.messageId);          // Обновляем состояние (например, меняем статус сообщения в списке)          messages = (state as ChatWithUserInitial).messages.reversed.toList();          if (index != -1) {            ChatMessage updatedMessage = messages[index].copyWith(              sendedError: false,              isMessageSend: true,            );            messages[index] = updatedMessage;            // Обновляем UI, чтобы сразу отобразить изменения          }          emit((state as ChatWithUserInitial).copyThis(              pageState: PageState.ready,              messages: messages.reversed.toList()));          await _loadChatData(              LoadChatData(                  chatId: (state as ChatWithUserInitial).chatData!.chatId!),              emit);        }        return;      }      final response = await NetworkService().ChatsSendMessage(          accessToken!,          message.message!,          (state as ChatWithUserInitial).chatData!.chatId!,          message.messageType!);      if (response.statusCode == 200) {        // Если успешно, удаляем сообщение из локального хранилища        await LocalMessageStorage.removeUnsentMessage(            chatId, message.messageId);        // Обновляем состояние (например, меняем статус сообщения в списке)        messages = (state as ChatWithUserInitial).messages.reversed.toList();        if (index != -1) {          ChatMessage updatedMessage = messages[index].copyWith(            sendedError: false,            isMessageSend: true,          );          messages[index] = updatedMessage;          // Обновляем UI, чтобы сразу отобразить изменения        }        emit((state as ChatWithUserInitial).copyThis(            pageState: PageState.ready, messages: messages.reversed.toList()));        await _loadChatData(            LoadChatData(                chatId: (state as ChatWithUserInitial).chatData!.chatId!),            emit);      }    } catch (e) {      log("Ошибка повторной отправки сообщения ${message.messageId}: $e");      final int index =          messages.indexWhere((m) => m.messageId == message.messageId);      if (index != -1) {        ChatMessage updatedMessage = messages[index].copyWith(          sendedError: true,          isMessageSend: false,        );        messages[index] = updatedMessage;        // Обновляем UI, чтобы сразу отобразить изменения        emit((state as ChatWithUserInitial)            .copyThis(messages: messages.reversed.toList()));      }    }  }  bool _isResending = false;  Future<void> _resendUnsentMessages(      RetrySendAllUnsentMessages event, Emitter<ChatWithUserState> emit) async {    if (_isResending) return; // Если процесс уже запущен, ничего не делаем    _isResending = true;    // Получаем идентификатор чата в виде строки для работы с локальным хранилищем    try {      print("resend starts");      final chatId =          (state as ChatWithUserInitial).chatData!.chatId!.toString();      // Загружаем неотправленные сообщения именно для этого чата      final unsentMessages =          await LocalMessageStorage.loadUnsentMessagesForChat(chatId);      print("unsentMessages for chat $chatId: $unsentMessages");      List<ChatMessage> messages =          (state as ChatWithUserInitial).messages.reversed.toList();      await getAccessToken();      for (ChatMessage unsent in unsentMessages) {        try {          final int index =              messages.indexWhere((m) => m.messageId == unsent.messageId);          if (index != -1) {            ChatMessage updatedMessage = messages[index].copyWith(              sendedError: false,              isMessageSend: false,            );            messages[index] = updatedMessage;            // Обновляем UI, чтобы сразу отобразить изменения            emit((state as ChatWithUserInitial)                .copyThis(messages: messages.reversed.toList()));          }          print("msg: ${unsent.message} going to server");          if (unsent.messageType == "file" ||              unsent.messageType == "image" ||              unsent.messageType == "video" ||              unsent.messageType == "audio") {            var response = await NetworkService().UploadFileRequest(              accessToken!,              unsent.message!,              unsent.messageType!,            );            // Check response status code            if (response.statusCode != 200) {              throw Exception('Failed to upload file: ${response.statusCode}');            }            // Collect the entire response body as a string            final responseBody = await response.stream.bytesToString();            // Debug print for response body            print('Response body: $responseBody');            // Decode the response body            final valueMap = json.decode(responseBody);            // Extract the file URL            final url = valueMap["fileURL"];            // Send message with the file URL            await NetworkService().ChatsSendMessage(              accessToken!,              url.toString(),              (state as ChatWithUserInitial).chatData!.chatId!,              unsent.messageType!,            );            if (response.statusCode == 200) {              // Если успешно, удаляем сообщение из локального хранилища              await LocalMessageStorage.removeUnsentMessage(                  chatId, unsent.messageId);              // Обновляем состояние (например, меняем статус сообщения в списке)              messages =                  (state as ChatWithUserInitial).messages.reversed.toList();              if (index != -1) {                ChatMessage updatedMessage = messages[index].copyWith(                  sendedError: false,                  isMessageSend: true,                );                messages[index] = updatedMessage;                // Обновляем UI, чтобы сразу отобразить изменения              }              emit((state as ChatWithUserInitial).copyThis(                  pageState: PageState.ready,                  messages: messages.reversed.toList()));              await _loadChatData(                  LoadChatData(                      chatId: (state as ChatWithUserInitial).chatData!.chatId!),                  emit);            }          } else {            final response = await NetworkService().ChatsSendMessage(                accessToken!,                unsent.message!,                (state as ChatWithUserInitial).chatData!.chatId!,                unsent.messageType!);            if (response.statusCode == 200) {              print("msg: ${unsent.message} success on server");              await LocalMessageStorage.removeUnsentMessage(                  chatId, unsent.messageId);              final int index =                  messages.indexWhere((m) => m.messageId == unsent.messageId);              if (index != -1) {                ChatMessage updatedMessage = messages[index].copyWith(                  isMessageSend: true,                );                messages[index] = updatedMessage;                // Обновляем UI, чтобы сразу отобразить изменения                emit((state as ChatWithUserInitial)                    .copyThis(messages: messages.reversed.toList()));              }            }          }        } catch (e) {          log("Ошибка повторной отправки: $e");          final int index =              messages.indexWhere((m) => m.messageId == unsent.messageId);          if (index != -1) {            ChatMessage updatedMessage = messages[index].copyWith(              isMessageSend: true,            );            messages[index] = updatedMessage;            // Обновляем UI, чтобы сразу отобразить изменения            emit((state as ChatWithUserInitial)                .copyThis(messages: messages.reversed.toList()));          }        }      }      await _loadChatData(          LoadChatData(              chatId: (state as ChatWithUserInitial).chatData!.chatId!),          emit);      print(          "unsent messages in end method : ${await LocalMessageStorage.loadUnsentMessagesForChat(chatId)}");    } finally {      _isResending = false;    }  }  Future<void> answerChat(      AsnwerChat answerChat, Emitter<ChatWithUserState> emit) async {    emit((state as ChatWithUserInitial).copyThis(      answerBoxVisible: true,      answerText: answerChat.answerText,      pageState: PageState.newMessage,    ));  }  Future<void> editChatActive(      EditChatActive editChat, Emitter<ChatWithUserState> emit) async {    emit(      (state as ChatWithUserInitial).copyThis(        editBoxVisible: true,        editText: editChat.editText,        pageState: PageState.newMessage,        editMessageId: editChat.messageId,      ),    );  }  Future<void> removeAnswerChat(      RemoveAnswerChat answerChat, Emitter<ChatWithUserState> emit) async {    emit((state as ChatWithUserInitial).copyThis(      answerBoxVisible: false,      editBoxVisible: false,      answerText: '',      editText: '',      pageState: PageState.hold,    ));  }  String? accessToken;  Future<void> getAccessToken() async {    SharedPreferences prefs = await SharedPreferences.getInstance();    accessToken = prefs.getString("token") ?? "";  }  Future<void> editChat(      EditChat editChat, Emitter<ChatWithUserState> emit) async {    var text = editChat.editText.trim();    if (text.isEmpty) {      return;    }    text = text.replaceAll(RegExp(r'((?<=\n)\s+)|((?<=\s)\s+)'), "");    if (accessToken == null) {      await getAccessToken();    }    List<ChatMessage> messages =        (state as ChatWithUserInitial).messages.reversed.toList().map((e) {      if (e.messageId == editChat.messageId) {        return e.copyWith(message: editChat.editText, edited: 'Изменено');      } else {        return e;      }    }).toList();    emit(      (state as ChatWithUserInitial).copyThis(        messages: messages.reversed.toList(),        editBoxVisible: false,        editText: '',        editMessageId: null,      ),    );    try {      var response = await NetworkService().ChatsEditMessage(        text,        editChat.messageId,      );      if (response.statusCode != 200) {        throw Exception("Error on edited");      }    } catch (err) {      emit(        (state as ChatWithUserInitial).copyThis(          pageState: PageState.error,          messages: messages.reversed.toList(),          editBoxVisible: false,          editText: '',          editMessageId: null,        ),      );      return;    }    emit((state as ChatWithUserInitial).copyThis(      pageState: PageState.ready,      messages: messages.reversed.toList(),      editBoxVisible: false,      answerBoxVisible: false,      editText: '',      editMessageId: null,    ));  }  DateTime _parseMessageTime(ChatMessage message) {    final format = DateFormat("dd.MM.yyyy HH:mm:ss");    // Если сообщение локальное, просто парсим как локальное время    if (message.isMessageSend == false) {      return format.parse(message.messageTime!);    } else {      // Серверное сообщение: время записано в UTC+3.      // Сначала парсим как обычное время, затем вычитаем 3 часа и переводим в локальное время.      final dtServer = format.parse(message.messageTime!);      return dtServer.subtract(const Duration(hours: 3)).toLocal();    }  }  Future<void> _loadChatData(      LoadChatData event, Emitter<ChatWithUserState> emit) async {    if (accessToken == null) {      await getAccessToken();    }    List<ChatMessage> serverMessages = [];    int userId = 0;    try {      var response =          await NetworkService().ChatsGetChatID(accessToken!, event.chatId);      userId = jsonDecode(response.body)["chat"]["userId"];      if (response.statusCode != 200) {        throw Exception("Error on send");      }      List<dynamic> receivedMessages = jsonDecode(response.body)["messages"];      for (int i = 0; i < receivedMessages.length; i++) {        ChatMessage message = ChatMessage();        message.GetDataFromJson(receivedMessages[i]);        log("Messages: ${message.toString()}");        if (message.isMessageSeen! == false &&            message.isAuthUsermessage! == false) {          NetworkService().ChatsSeenMessageID(accessToken!, message.messageId!);        }        serverMessages.add(message);      }    } catch (err) {      emit((state as ChatWithUserInitial).copyThis(        pageState: PageState.error,      ));    }    // Загружаем локальные (неотправленные) сообщения для этого чата    final chatId = (state as ChatWithUserInitial).chatData!.chatId!.toString();    List<ChatMessage> unsentMessages =        await LocalMessageStorage.loadUnsentMessagesForChat(chatId);    // Объединяем серверные и локальные сообщения    List<ChatMessage> mergedMessages = [...serverMessages, ...unsentMessages];    // Сортируем объединённый список по времени (приведённому к локальному времени)    debugPrint("before merg: ${mergedMessages.reversed.toList()}");    mergedMessages.sort((a, b) {      DateTime dtA = _parseMessageTime(a);      DateTime dtB = _parseMessageTime(b);      return dtA.compareTo(dtB);    });    debugPrint("after merg: ${mergedMessages.reversed.toList()}");    emit((state as ChatWithUserInitial).copyThis(        chatData:            (state as ChatWithUserInitial).chatData!.copyThis(userID: userId),        pageState: PageState.ready,        messages: mergedMessages.reversed.toList()));  }  void _newMessage(NewMessage event, Emitter<ChatWithUserState> emit) async {    if (accessToken == null) {      await getAccessToken();    }    List<ChatMessage> messages =        (state as ChatWithUserInitial).messages.reversed.toList();    ChatMessage message = ChatMessage();    try {      var response = await NetworkService()          .ChatsGetMessageByID(accessToken!, event.messageId);      if (response.statusCode != 200) {        throw Exception("Error on send");      }      message.GetDataFromJson(jsonDecode(response.body));      if (message.isAuthUsermessage == false) {        response = await NetworkService()            .ChatsSeenMessageID(accessToken!, event.messageId);      }    } catch (err) {      emit((state as ChatWithUserInitial).copyThis(        pageState: PageState.error,      ));      return;    }    messages.add(message);    emit((state as ChatWithUserInitial).copyThis(        pageState: PageState.ready, messages: messages.reversed.toList()));  }  void _readMessage(ReadMessage event, Emitter<ChatWithUserState> emit) async {    if (accessToken == null) {      await getAccessToken();    }    List<ChatMessage> messages =        (state as ChatWithUserInitial).messages.reversed.toList();    for (int i = messages.length - 1; i > 0; i--) {      if (messages[i].isMessageSeen != true) {        messages[i].isMessageSeen = true;      } else {        break;      }    }    emit((state as ChatWithUserInitial).copyThis(      pageState: PageState.loading,    ));    emit((state as ChatWithUserInitial).copyThis(        pageState: PageState.ready, messages: messages.reversed.toList()));  }  void _blockChat(BlockChat event, Emitter<ChatWithUserState> emit) async {    if (accessToken == null) {      await getAccessToken();    }    try {      if ((state as ChatWithUserInitial).chatData!.isChatBlocked) {        await NetworkService().unblockUser(            userId: (state as ChatWithUserInitial).chatData!.userID!);      } else {        await NetworkService().blockUser(            userId: (state as ChatWithUserInitial).chatData!.userID!);      }    } catch (err) {      emit((state as ChatWithUserInitial).copyThis(        pageState: PageState.error,      ));      return;    }    emit((state as ChatWithUserInitial).copyThis(      chatData: (state as ChatWithUserInitial).chatData!.copyThis(          isChatBlocked:              (state as ChatWithUserInitial).chatData!.isChatBlocked == false),      pageState: PageState.ready,    ));  }  ChatMessage createMsg(      {required String str,      required String type,      bool isMessageSend = false,      bool sendedError = false}) {    ChatMessage message = ChatMessage();    ///Чтобы была возможность локального удаления    message.messageId = DateTime.now().millisecondsSinceEpoch;    message.message = str;    DateTime dt = DateTime.now();    dt = dt.add(const Duration(hours: 3) - DateTime.now().timeZoneOffset);    message.messageTime =        '${dt.day.toString().padLeft(2, '0')}.${dt.month.toString().padLeft(2, '0')}.${dt.year} '        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}:${dt.second.toString().padLeft(2, '0')}';    message.isAuthUsermessage = true;    message.isMessageSeen = false;    message.messageType = type;    message.isMessageSend = isMessageSend;    message.sendedError = sendedError;    return message;  }  void _sendMessage(    SendTextMessage event,    Emitter<ChatWithUserState> emit,  ) async {    print("aaaaaa");    var text = event.text.trim();    if (text.isEmpty) {      return;    }    text = text.replaceAll(RegExp(r'((?<=\n)\s+)|((?<=\s)\s+)'), "");    if (accessToken == null) {      await getAccessToken();    }    List<ChatMessage> messages =        (state as ChatWithUserInitial).messages.reversed.toList();    final message = createMsg(str: text, type: "text");    messages.add(message);    emit((state as ChatWithUserInitial)        .copyThis(messages: messages.reversed.toList()));    // Определяем идентификатор чата для работы с локальным хранилищем    final chatId = (state as ChatWithUserInitial).chatData!.chatId!.toString();    // Проверяем наличие подключения к интернету    final connectivityResult = await Connectivity().checkConnectivity();    if (connectivityResult.contains(ConnectivityResult.none)) {      print("Нет интернета, сообщение будет сохранено как неотправленное");      final int index =          messages.indexWhere((m) => m.messageId == message.messageId);      if (index != -1) {        ChatMessage updatedMessage = messages[index].copyWith(          sendedError: true,          isMessageSend: false,        );        messages[index] = updatedMessage;        emit(          (state as ChatWithUserInitial).copyThis(            pageState: PageState.error,            messages: messages.reversed.toList(),          ),        );      }      // Сохраняем сообщение в локальное хранилище для этого чата      await LocalMessageStorage.saveUnsentMessage(chatId, messages[index]);      return;    }    print("before send");    try {      var response = await NetworkService().ChatsSendMessage(accessToken!, text,          (state as ChatWithUserInitial).chatData!.chatId!, "text");      print("in send");      if (response.statusCode != 200) {        print("inside send != 200 if");        throw Exception("Error on send");      }    } catch (err) {      print("inside catch");      final int index =          messages.indexWhere((m) => m.messageId == message.messageId);      if (index != -1) {        ChatMessage updatedMessage = messages[index].copyWith(          sendedError: true,          isMessageSend: false,        );        messages[index] = updatedMessage;        emit(          (state as ChatWithUserInitial).copyThis(            pageState: PageState.error,            messages: messages.reversed.toList(),          ),        );      }      print("message for save: ${messages[index]}");      // Сохраняем неотправленное сообщение в локальное хранилище для данного чата      final chatId =          (state as ChatWithUserInitial).chatData!.chatId!.toString();      await LocalMessageStorage.saveUnsentMessage(chatId, messages[index]);      return;    }    messages = (state as ChatWithUserInitial).messages.reversed.toList();    final int index =        messages.indexWhere((m) => m.messageId == message.messageId);    if (index != -1) {      ChatMessage updatedMessage = messages[index].copyWith(        isMessageSend: true,      );      messages[index] = updatedMessage;      emit(        (state as ChatWithUserInitial).copyThis(          pageState: PageState.ready,          messages: messages.reversed.toList(),        ),      );    }    ///TODO здесь каждый раз получаем чат чтобы обновить сообщения с сервера    // List<ChatMessage> messages1 = [];    // int userId = 0;    // try {    //   var response =    //       await NetworkService().ChatsGetChatID(accessToken!, event.chatId);    //    //   userId = jsonDecode(response.body)["chat"]["userId"];    //    //   if (response.statusCode != 200) {    //     throw Exception("Error on send");    //   }    //    //   List<dynamic> receivedMessages = jsonDecode(response.body)["messages"];    //    //   print("step two");    //   for (int i = 0; i < receivedMessages.length; i++) {    //     ChatMessage message = ChatMessage();    //     message.GetDataFromJson(receivedMessages[i]);    //    //     messages1.add(message);    //   }    // } catch (err) {    //   emit((state as ChatWithUserInitial).copyThis(    //     pageState: PageState.error,    //   ));    // }    //    // emit((state as ChatWithUserInitial).copyThis(    //     chatData:    //         (state as ChatWithUserInitial).chatData!.copyThis(userID: userId),    //     pageState: PageState.ready,    //     messages: messages1.reversed.toList()));  }  void _sendFile(SendFile event, Emitter<ChatWithUserState> emit) async {    if (accessToken == null) {      await getAccessToken();    }    List<ChatMessage> messages =        (state as ChatWithUserInitial).messages.reversed.toList();    final message = createMsg(str: event.file.path, type: event.fileType);    messages.add(message);    // Emit loading state    emit((state as ChatWithUserInitial).copyThis(        pageState: PageState.loading, messages: messages.reversed.toList()));    // Определяем идентификатор чата для работы с локальным хранилищем    final chatId = (state as ChatWithUserInitial).chatData!.chatId!.toString();    // Проверяем наличие подключения к интернету    final connectivityResult = await Connectivity().checkConnectivity();    if (connectivityResult.contains(ConnectivityResult.none)) {      print("Нет интернета, сообщение будет сохранено как неотправленное");      final int index =          messages.indexWhere((m) => m.messageId == message.messageId);      if (index != -1) {        ChatMessage updatedMessage = messages[index].copyWith(          sendedError: true,          isMessageSend: false,        );        messages[index] = updatedMessage;        emit(          (state as ChatWithUserInitial).copyThis(            pageState: PageState.error,            messages: messages.reversed.toList(),          ),        );      }      // Сохраняем сообщение в локальное хранилище для этого чата      await LocalMessageStorage.saveUnsentMessage(chatId, messages[index]);      return;    }    try {      // Send file upload request      var response = await NetworkService()          .UploadFileRequest(accessToken!, event.file.path, event.fileType);      // Check response status code      if (response.statusCode != 200) {        throw Exception('Failed to upload file: ${response.statusCode}');      }      // Collect the entire response body as a string      final responseBody = await response.stream.bytesToString();      // Debug print for response body      print('Response body: $responseBody');      // Decode the response body      final valueMap = json.decode(responseBody);      // Extract the file URL      final url = valueMap["fileURL"];      // Send message with the file URL      await NetworkService().ChatsSendMessage(accessToken!, url.toString(),          (state as ChatWithUserInitial).chatData!.chatId!, event.fileType);      // Optional: Update messages list to reflect sent status      final int index =          messages.indexWhere((m) => m.messageId == message.messageId);      if (index != -1) {        ChatMessage updatedMessage = messages[index].copyWith(          isMessageSend: true,          message: url.toString(),        );        messages[index] = updatedMessage;        emit(          (state as ChatWithUserInitial).copyThis(            pageState: PageState.ready,            messages: messages.reversed.toList(),          ),        );      }      print("File URL: $url");    } catch (error) {      // Print and handle errors      print('Error during file upload or JSON decoding: $error');      print("inside catch");      final int index =          messages.indexWhere((m) => m.messageId == message.messageId);      if (index != -1) {        ChatMessage updatedMessage = messages[index].copyWith(          sendedError: true,          isMessageSend: false,        );        messages[index] = updatedMessage;        emit(          (state as ChatWithUserInitial).copyThis(            pageState: PageState.error,            messages: messages.reversed.toList(),          ),        );      }      print("message for save: ${messages[index]}");      // Сохраняем неотправленное сообщение в локальное хранилище для данного чата      final chatId =          (state as ChatWithUserInitial).chatData!.chatId!.toString();      await LocalMessageStorage.saveUnsentMessage(chatId, messages[index]);      return;    }  }  FutureOr<void> _deleteMessageWithId(      DeleteChatMessageWithId event, Emitter<ChatWithUserState> emit) async {    final chatId = (state as ChatWithUserInitial).chatData!.chatId!.toString();    final unsentMessages =        await LocalMessageStorage.loadUnsentMessagesForChat(chatId);    final ChatMessage? message = unsentMessages.firstWhereOrNull(      (msg) => msg.messageId == event.messageId,    );    List<ChatMessage> messages =        (state as ChatWithUserInitial).messages.reversed.toList();    final int index =        messages.indexWhere((m) => m.messageId == event.messageId);    if (index != -1) {      ChatMessage updatedMessage = messages[index].copyWith(        sendedError: false,        isMessageSend: false,      );      messages[index] = updatedMessage;      emit((state as ChatWithUserInitial)          .copyThis(messages: messages.reversed.toList()));    }    if (message != null) {      await LocalMessageStorage.removeUnsentMessage(        chatId,        message.messageId,      );      messages = (state as ChatWithUserInitial).messages.reversed.toList();      final int index =          messages.indexWhere((m) => m.messageId == event.messageId);      if (index != -1) {        messages.removeAt(index);        emit((state as ChatWithUserInitial)            .copyThis(messages: messages.reversed.toList()));      }    } else {      SharedPreferences prefs = await SharedPreferences.getInstance();      String accessToken = prefs.getString("token") ?? "";      String csrfToken = "LHXZTMpSzw8TCVkXqAO6LFG41B4cN1Oth80CvX7J";      if (accessToken.isEmpty) {        debugPrint("Token not found.");        return;      }      Dio dio = Dio();      try {        Response response = await dio.delete(          'https://www.nikahtime.ru/api/chats/messages/${event.messageId}',          options: Options(            headers: {              'accept': 'application/json',              'Authorization': 'Bearer $accessToken',              'X-CSRF-TOKEN': csrfToken,            },          ),        );        if (response.statusCode == 200) {          debugPrint('Message deleted successfully');          messages = (state as ChatWithUserInitial).messages.reversed.toList();          final int index =              messages.indexWhere((m) => m.messageId == event.messageId);          if (index != -1) {            messages.removeAt(index);            emit((state as ChatWithUserInitial)                .copyThis(messages: messages.reversed.toList()));          }        } else {          debugPrint('Failed to delete message: ${response.statusMessage}');        }      } catch (e) {        debugPrint('Error deleting message: $e');      }    }  }}